# 1. 몇 가지 기초 사항들

## 알고리즘 분석의 필요성
- 알고리즘을 설계하고 나면, 그 알고리즘이 자원을 얼마나 소모하는지 분석해야 함  
- 자원은 소요 시간/메모리/통신대역 등이 될 수도 있음 But 대부분은 **소요 시간**이 가장 중요한 관심 대상!  
- 시간의 분석은 아래와 같은 경우에 대한 분석이 대표적  
  1. 최악의 경우  
  2. 평균적인 경우  

## 알고리즘의 수행 시간  
- 알고리즘의 수행 시간은 **입력의 크기에 대해 시간이 어떤 비율로 소요되는지**로 표현함    
#### <예시> ####
#### 1. 입력의 크기가 n인 경우에 간단한 연산으로 계산할 수 있는 알고리즘  ####
```c
sample1(A[], n)
{
   k = [n/2];     // 1
   return A[k];   // 1
}
```
> 입력 배열의 크기 n에 상관없이 일정한 시간(상수 시간)이 소요된다. ∴ **O(1)** : Constant   
  
  
#### 2. 배열 A[1 … n]의 모든 원소를 더하는 알고리즘 ####   
```c
sample2(A[], n)
{
   sum ← 0;             // 1
   for i ← 1 to n       // n
      sum ← sum + A[i]; // 1
   return sum;          // 1
}
```
> for 루프를 제외한 나머지 부분은 상수 시간이 소요되므로 for 루프가 시간을 지배  
> for 루프 관련 수행 시간 : n에 비례 (for 루프는 n번 반복, 각 루프에서는 단순한 덧셈만 하므로 상수 시간이 소요되어)  
> 알고리즘 수행 시간: n에 비례. ∴ **O(n)** : Linear  
  
  
#### 3. 배열 A[1 … n]의 모든 원소 쌍을 곱한 합을 구하는 알고리즘 (중첩 for 루프)  ####  
```c
sample3(A[], n)
{
   sum ← 0;             // 1
   for i ← 1 to n
      for j ← 1 to n
         sum ← sum + A[i] * A[j];
   return sum;
}
```
> for 루프: n × n = n²번 반복
> 각 루프: 덧셈 한 번, 곱셈 한 번 → 상수 시간  
> 알고리즘 수행 시간: n²에 비례   ∴ **O(n<sup>c</sup>)** : Polynomial  
  
    
#### 4. for 루프를 n²번 반복하면서 매번 배열에서 반을 임의로 뽑아 그중 최댓값을 계속 더하는 알고리즘
```c
sample4(A[], n)
{
   sum ← 0;             // 1
   for i ← 1 to n
      for j ← 1 to n {
         ① k ← A[1 … n] 에서 임의로 [n/2]개를 뽑을 때 이들 중 최댓값;
         sum ← sum + k;
      }
   return sum;
}
```  
> 크기가 n인 배열에서 [n/2]개를 뽑으면서 이들 중 최댓값을 구하는 것: n/2에 비례    
> ①을 수행하는 데 비례하는 시간: n  
> 전체적으로 for 루프의 반복 횟수와 ①의 수행 시간이 시간을 좌우  
> 알고리즘 수행 시간: n² × n = n³   
  
#### 5. 배열 A[1...n]에서 i < j인 모든 원소 쌍의 곱을 합산하는 알고리즘
```c
sample5(A[], n)
{
   sum ← 0;             // 1
   for i ← 1 to n-1
      for j ← i+1 to n
         ① sum ← sum + A[i]*A[j];
   return sum;
```  
> ①을 수행하는 데 비례하는 시간: 상수 시간    
> 전체적으로 for 루프의 총 반복 횟수가 수행 시간을 좌우   
> 바깥 for 루프에서 i=1일 때 안쪽 for 루프가 n-1회 반복,  
> 바깥 for 루프에서 i=2일 때 안쪽 for 루프가 n-2회 반복,  
> 바깥 for 루프에서 i=n-1일 때 안쪽 for 루프가 1회 반복,  
> 총 반복 횟수: (n+1)+(n-2)+...+2+1=n(n-1)/2 이 되어 n<sup>2</sup>에 비례  
> 알고리즘 수행 시간: n<sup>2</sup>  
  
# 2. 점근적 표기  
알고리즘의 수행 시간은 항상 입력의 크기가 충분히 클 때 분석함.  즉, **점근적 분석**을 함.  
  
## Θ-표기법  
- 대략 n² 에 비례하는 시간이 소요됨을 뜻함  
- Θ(f(n)): 점근적 증가율이 f(n)과 일치하는 모든 함수의 집합  
- **집합**으로 정의됨  
  
## Ο-표기법
- 기껏해야 n² 에 비례하는 시간이 소요됨을 뜻함  
- Ο(f(n)): 점근적 증가율이 f(n)을 넘지 않는 모든 함수의 집합 
- 함수의 점근적 상한을 나타냄  
  
## Ω-표기법  
- 적어도 n² 에 비례하는 시간이 소요됨을 뜻함  
- Ω(f(n)): 점근적 증가율이 적어도 f(n)이 되는 모든 함수의 집합  
  ∴ 최고차항의 차수가 f(n)과 일치하거나 더 큰 함수의 집합  
- 함수의 점근적 하한을 나타냄  
