# 1. 기본적인 정렬 알고리즘
## ① 선택 정렬  
![2](https://user-images.githubusercontent.com/50271884/66739470-ba10eb00-eeab-11e9-8d11-9c051d6a3543.png)  

### [ 개념 ]  
- 원리가 간단한 정렬 알고리즘 중 하나  
  1. 우선 배열 A[1 ... n]에서 가장 큰 원소를 찾아 이 원소와 배열의 끝자리에 있는 A[n]과 자리를 바꿈 
  2. 그러면 방금 맨 뒷자리로 옮긴 원소, 즉 가장 큰 원소는 자기 자리를 찾았으므로 더 이상 신경쓰지 않아도 OK  
  3. ⅲ에서의 원소는 정렬이 끝났다고 볼 수 있음 &nbsp;&nbsp;&nbsp; ∴ 나머지 원소들로 같은 작업 반복하면 됨
  
### [ 알고리즘 ]  
  
```java
selectionSort(A[], n) 
{
  ① for last ← n downto 2 {
    ② A[1...last] 중 가장 큰 수 A[k]를 찾는다;
    ③ A[k] ↔ A[last];  //A[k]와 A[last]의 값을 교환
  }
}
```
- ①에서 변수 last는 정렬할 배열의 맨 마지막 인덱스, 즉 배열의 크기를 나타냄
  - 처음에는 배열의 크기가 n으로 시작하므로 A[1 ... n]을 정렬 대상으로 삼음
  - 가장 큰 수를 찾아 제자리에 놓을 때마다 last는 1씩 줄어듦
- ①의 for 루프는 정렬할 배열의 크기를 한 번에 하나씩 줄여나가는 역할을 함
  - 맨 처음에는 배열의 크기가 n으로 시작하여,  
    그다음 루프에서는 n-1(정렬할 배열: A[1 ... n-1]), n-2(정렬할 배열: A[1 ... n-2]), ... 이렇게 계속 작아짐
  - 마지막에는 크기 2인 배열 A[1 ... 2]의 두 원소 중 큰 원소를 A[2]에 놓고 나면 A[1]에는 제일 작은 원소가 자리잡게 되므로 정렬 끝!  
    
  #### ❔ 만약, n = 1 이라면 어떤 일이 일어날까?    
  > * ①의 for 루프는 last가 n ... 2까지 감소하면서 반복됨  
  > * But 시작에서 last = 1이므로 2보다 작으므로 for루프를 한 번도 수행하지 않고 지나감  
  > * 즉, A[1] 하나로 정렬을 요구하면 아무 일도 하지 않고 그냥 끝내는 것  
  
- **실행 시간**
  - ①의 for 루프: n-1 번 반복
  - ②에서 가장 큰 수를 찾기 위한 비교횟수: n-1, n-2, ..., 2, 1
  - ③의 교환: c의 작업 (c: 상수시간)  
- **시간복잡도**  
  T(n) = n-1 + n-2 + ... + 2 + 1 = O(n<sup>2</sup>)  
  

<hr>
  
